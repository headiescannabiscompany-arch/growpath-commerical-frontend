const express = require("express");
const router = express.Router();
const auth = require("../middleware/auth");
const proOnly = require("../middleware/proOnly");
const OpenAI = require("openai");
const Task = require("../models/Task");
const Plant = require("../models/Plant");

const ai = new OpenAI({ apiKey: process.env.OPENAI_API_KEY });

const envPromptBase = `
You are an expert cannabis cultivation environmental consultant.

Given environmental parameters and plant stage, respond STRICTLY in this JSON:

{
  "targets": {
    "tempDayC": 0,
    "tempNightC": 0,
    "humidityMin": 0,
    "humidityMax": 0,
    "vpdIdeal": 0,
    "ppfdMin": 0,
    "ppfdMax": 0,
    "dliMin": 0,
    "dliMax": 0,
    "co2Ideal": 0
  },
  "currentAssessment": {
    "vpd": 0,
    "status": "too dry | too humid | too cold | too hot | too dim | too intense | balanced",
    "issues": [],
    "riskFlags": [] 
  },
  "recommendations": {
    "actions": [
      {
        "title": "",
        "details": "",
        "priority": "low | medium | high"
      }
    ],
    "light": [],
    "air": [],
    "humidity": [],
    "temperature": [],
    "co2": [],
    "other": []
  },
  "notes": ""
}

Rules:
- Tailor targets to the stage (seedling, veg, early flower, mid flower, late flower, dry/cure).
- Use realistic cannabis indoor ranges.
- If VPD input missing, estimate from temp/RH only.
- If DLI not provided, infer from PPFD and common photoperiod settings.
- Always output valid JSON, no comments.
`;

router.post("/analyze", auth, proOnly, async (req, res) => {
  const { stage, tempDayC, tempNightC, humidity, vpd, ppfd, dli, co2, lightHours, strainType, medium } = req.body;

  const userEnv = { stage, tempDayC, tempNightC, humidity, vpd, ppfd, dli, co2, lightHours, strainType, medium };

  const prompt = `
${envPromptBase}

User environment:

${JSON.stringify(userEnv, null, 2)}
`;

  try {
    const result = await ai.chat.completions.create({
      model: "gpt-4o-mini",
      max_tokens: 900,
      messages: [{ role: "system", content: prompt }]
    });

    const env = JSON.parse(result.choices[0].message.content);
    res.json({ success: true, env });
  } catch (err) {
    console.error(err);
    res.status(500).json({ success: false, error: "Environment analysis failed" });
  }
});

// Convert recommendations to tasks for a plant
router.post("/:plantId/to-tasks", auth, proOnly, async (req, res) => {
  const { actions } = req.body; // array of { title, details, priority }
  const plant = await Plant.findOne({ _id: req.params.plantId, user: req.userId });

  if (!plant) return res.status(404).json({ message: "Plant not found" });

  const today = new Date();
  const created = [];

  for (const action of actions || []) {
    const task = await Task.create({
      user: req.userId,
      plant: plant._id,
      title: action.title,
      description: action.details,
      dueDate: today,
      type: "custom",
      priority: action.priority === "high" ? 2 : 1,
      autoGenerated: true,
    });
    created.push(task);
  }

  res.json({ success: true, tasks: created });
});

module.exports = router;
