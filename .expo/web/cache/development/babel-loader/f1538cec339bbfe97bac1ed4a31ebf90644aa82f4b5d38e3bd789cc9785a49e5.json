{"ast":null,"code":"import _asyncToGenerator from \"@babel/runtime/helpers/asyncToGenerator\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nimport { LegacyEventEmitter, CodedError, UnavailabilityError } from 'expo-modules-core';\nimport NotificationsHandlerModule from \"./NotificationsHandlerModule\";\nimport { mapNotification } from \"./utils/mapNotificationResponse\";\nexport var NotificationTimeoutError = function (_CodedError) {\n  function NotificationTimeoutError(notificationId, notification) {\n    var _this;\n    _classCallCheck(this, NotificationTimeoutError);\n    _this = _callSuper(this, NotificationTimeoutError, ['ERR_NOTIFICATION_TIMEOUT', `Notification handling timed out for ID ${notificationId}.`]);\n    _this.info = {\n      id: notificationId,\n      notification: notification\n    };\n    return _this;\n  }\n  _inherits(NotificationTimeoutError, _CodedError);\n  return _createClass(NotificationTimeoutError);\n}(CodedError);\nvar notificationEmitter = new LegacyEventEmitter(NotificationsHandlerModule);\nvar handleNotificationEventName = 'onHandleNotification';\nvar handleNotificationTimeoutEventName = 'onHandleNotificationTimeout';\nvar handleSubscription = null;\nvar handleTimeoutSubscription = null;\nexport function setNotificationHandler(handler) {\n  if (handleSubscription) {\n    handleSubscription.remove();\n    handleSubscription = null;\n  }\n  if (handleTimeoutSubscription) {\n    handleTimeoutSubscription.remove();\n    handleTimeoutSubscription = null;\n  }\n  if (handler) {\n    handleSubscription = notificationEmitter.addListener(handleNotificationEventName, function () {\n      var _ref2 = _asyncToGenerator(function* (_ref) {\n        var id = _ref.id,\n          notification = _ref.notification;\n        if (!NotificationsHandlerModule.handleNotificationAsync) {\n          handler.handleError == null ? void 0 : handler.handleError(id, new UnavailabilityError('Notifications', 'handleNotificationAsync'));\n          return;\n        }\n        try {\n          var mappedNotification = mapNotification(notification);\n          var behavior = yield handler.handleNotification(mappedNotification);\n          if (behavior.shouldShowAlert) {\n            console.warn('[expo-notifications]: `shouldShowAlert` is deprecated. Specify `shouldShowBanner` and / or `shouldShowList` instead.');\n          }\n          yield NotificationsHandlerModule.handleNotificationAsync(id, behavior);\n          handler.handleSuccess == null ? void 0 : handler.handleSuccess(id);\n        } catch (error) {\n          handler.handleError == null ? void 0 : handler.handleError(id, error);\n        }\n      });\n      return function (_x) {\n        return _ref2.apply(this, arguments);\n      };\n    }());\n    handleTimeoutSubscription = notificationEmitter.addListener(handleNotificationTimeoutEventName, function (_ref3) {\n      var id = _ref3.id,\n        notification = _ref3.notification;\n      return handler.handleError == null ? void 0 : handler.handleError(id, new NotificationTimeoutError(id, mapNotification(notification)));\n    });\n  }\n}","map":{"version":3,"names":["LegacyEventEmitter","CodedError","UnavailabilityError","NotificationsHandlerModule","mapNotification","NotificationTimeoutError","_CodedError","notificationId","notification","_this","_classCallCheck","_callSuper","info","id","_inherits","_createClass","notificationEmitter","handleNotificationEventName","handleNotificationTimeoutEventName","handleSubscription","handleTimeoutSubscription","setNotificationHandler","handler","remove","addListener","_ref2","_asyncToGenerator","_ref","handleNotificationAsync","handleError","mappedNotification","behavior","handleNotification","shouldShowAlert","console","warn","handleSuccess","error","_x","apply","arguments","_ref3"],"sources":["C:\\GrowPathAI-UI\\node_modules\\expo-notifications\\src\\NotificationsHandler.ts"],"sourcesContent":["import {\n  LegacyEventEmitter,\n  type EventSubscription,\n  CodedError,\n  UnavailabilityError,\n} from 'expo-modules-core';\n\nimport { Notification, NotificationBehavior } from './Notifications.types';\nimport NotificationsHandlerModule from './NotificationsHandlerModule';\nimport { mapNotification } from './utils/mapNotificationResponse';\n\n/**\n * @hidden\n */\nexport class NotificationTimeoutError extends CodedError {\n  info: { notification: Notification; id: string };\n  constructor(notificationId: string, notification: Notification) {\n    super('ERR_NOTIFICATION_TIMEOUT', `Notification handling timed out for ID ${notificationId}.`);\n    this.info = { id: notificationId, notification };\n  }\n}\n\n// @docsMissing\nexport type NotificationHandlingError = NotificationTimeoutError | Error;\n\nexport interface NotificationHandler {\n  /**\n   * A function accepting an incoming notification returning a `Promise` resolving to a behavior ([`NotificationBehavior`](#notificationbehavior))\n   * applicable to the notification\n   * @param notification An object representing the notification.\n   */\n  handleNotification: (notification: Notification) => Promise<NotificationBehavior>;\n  /**\n   * A function called whenever an incoming notification is handled successfully.\n   * @param notificationId Identifier of the notification.\n   */\n  handleSuccess?: (notificationId: string) => void;\n  /**\n   * A function called whenever calling `handleNotification()` for an incoming notification fails.\n   * @param notificationId Identifier of the notification.\n   * @param error An error which occurred in form of `NotificationHandlingError` object.\n   */\n  handleError?: (notificationId: string, error: NotificationHandlingError) => void;\n}\n\ntype HandleNotificationEvent = {\n  id: string;\n  notification: Notification;\n};\n\ntype HandleNotificationTimeoutEvent = HandleNotificationEvent;\n\n// Web uses SyntheticEventEmitter\nconst notificationEmitter = new LegacyEventEmitter(NotificationsHandlerModule);\n\nconst handleNotificationEventName = 'onHandleNotification';\nconst handleNotificationTimeoutEventName = 'onHandleNotificationTimeout';\n\nlet handleSubscription: EventSubscription | null = null;\nlet handleTimeoutSubscription: EventSubscription | null = null;\n\n/**\n * When a notification is received while the app is running, using this function you can set a callback that will decide\n * whether the notification should be shown to the user or not.\n *\n * When a notification is received, `handleNotification` is called with the incoming notification as an argument.\n * The function should respond with a behavior object within 3 seconds, otherwise, the notification will be discarded.\n * If the notification is handled successfully, `handleSuccess` is called with the identifier of the notification,\n * otherwise (or on timeout) `handleError` will be called.\n *\n * The default behavior when the handler is not set or does not respond in time is not to show the notification.\n * @param handler A single parameter which should be either `null` (if you want to clear the handler) or a [`NotificationHandler`](#notificationhandler) object.\n *\n * @example Implementing a notification handler that always shows the notification when it is received.\n * ```jsx\n * import * as Notifications from 'expo-notifications';\n *\n * Notifications.setNotificationHandler({\n *   handleNotification: async () => ({\n *     shouldShowBanner: true,\n *     shouldShowList: true,\n *     shouldPlaySound: false,\n *     shouldSetBadge: false,\n *   }),\n * });\n * ```\n * @header inForeground\n */\nexport function setNotificationHandler(handler: NotificationHandler | null): void {\n  if (handleSubscription) {\n    handleSubscription.remove();\n    handleSubscription = null;\n  }\n  if (handleTimeoutSubscription) {\n    handleTimeoutSubscription.remove();\n    handleTimeoutSubscription = null;\n  }\n\n  if (handler) {\n    handleSubscription = notificationEmitter.addListener<HandleNotificationEvent>(\n      handleNotificationEventName,\n      async ({ id, notification }) => {\n        if (!NotificationsHandlerModule.handleNotificationAsync) {\n          handler.handleError?.(\n            id,\n            new UnavailabilityError('Notifications', 'handleNotificationAsync')\n          );\n          return;\n        }\n\n        try {\n          const mappedNotification = mapNotification(notification);\n          const behavior = await handler.handleNotification(mappedNotification);\n\n          if (behavior.shouldShowAlert) {\n            console.warn(\n              '[expo-notifications]: `shouldShowAlert` is deprecated. Specify `shouldShowBanner` and / or `shouldShowList` instead.'\n            );\n          }\n          await NotificationsHandlerModule.handleNotificationAsync(id, behavior);\n          handler.handleSuccess?.(id);\n        } catch (error: any) {\n          // TODO(@kitten): This callback expects specific Error types, but we never narrow the type before calling this callback\n          handler.handleError?.(id, error);\n        }\n      }\n    );\n\n    handleTimeoutSubscription = notificationEmitter.addListener<HandleNotificationTimeoutEvent>(\n      handleNotificationTimeoutEventName,\n      ({ id, notification }) =>\n        handler.handleError?.(id, new NotificationTimeoutError(id, mapNotification(notification)))\n    );\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}