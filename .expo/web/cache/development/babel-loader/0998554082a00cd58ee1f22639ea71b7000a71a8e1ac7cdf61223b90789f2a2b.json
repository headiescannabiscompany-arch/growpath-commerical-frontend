{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _objectWithoutProperties from \"@babel/runtime/helpers/objectWithoutProperties\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/asyncToGenerator\";\nvar _excluded = [\"repeats\"];\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nimport { Platform, UnavailabilityError, uuid } from 'expo-modules-core';\nimport NotificationScheduler from \"./NotificationScheduler\";\nimport { SchedulableTriggerInputTypes } from \"./Notifications.types\";\nimport { hasValidTriggerObject } from \"./hasValidTriggerObject\";\nexport default function scheduleNotificationAsync(_x) {\n  return _scheduleNotificationAsync.apply(this, arguments);\n}\nfunction _scheduleNotificationAsync() {\n  _scheduleNotificationAsync = _asyncToGenerator(function* (request) {\n    var _request$identifier;\n    if (!NotificationScheduler.scheduleNotificationAsync) {\n      throw new UnavailabilityError('Notifications', 'scheduleNotificationAsync');\n    }\n    return yield NotificationScheduler.scheduleNotificationAsync((_request$identifier = request.identifier) != null ? _request$identifier : uuid.v4(), request.content, parseTrigger(request.trigger));\n  });\n  return _scheduleNotificationAsync.apply(this, arguments);\n}\nexport function parseTrigger(userFacingTrigger) {\n  if (userFacingTrigger === null) {\n    return null;\n  }\n  if (userFacingTrigger === undefined) {\n    throw new TypeError('Encountered an `undefined` notification trigger. If you want to trigger the notification immediately, pass in an explicit `null` value.');\n  }\n  if (!hasValidTriggerObject(userFacingTrigger)) {\n    throw new TypeError(`The \\`trigger\\` object you provided is invalid. It needs to contain a \\`type\\` or \\`channelId\\` entry. Refer to the documentation to update your code: https://docs.expo.dev/versions/latest/sdk/notifications/#notificationtriggerinput`);\n  }\n  var dateTrigger = parseDateTrigger(userFacingTrigger);\n  if (dateTrigger) {\n    return dateTrigger;\n  }\n  var calendarTrigger = parseCalendarTrigger(userFacingTrigger);\n  if (calendarTrigger) {\n    return calendarTrigger;\n  }\n  var dailyTrigger = parseDailyTrigger(userFacingTrigger);\n  if (dailyTrigger) {\n    return dailyTrigger;\n  }\n  var weeklyTrigger = parseWeeklyTrigger(userFacingTrigger);\n  if (weeklyTrigger) {\n    return weeklyTrigger;\n  }\n  var monthlyTrigger = parseMonthlyTrigger(userFacingTrigger);\n  if (monthlyTrigger) {\n    return monthlyTrigger;\n  }\n  var yearlyTrigger = parseYearlyTrigger(userFacingTrigger);\n  if (yearlyTrigger) {\n    return yearlyTrigger;\n  }\n  var timeIntervalTrigger = parseTimeIntervalTrigger(userFacingTrigger);\n  if (timeIntervalTrigger) {\n    return timeIntervalTrigger;\n  }\n  return Platform.select({\n    default: null,\n    android: {\n      type: 'channel',\n      channelId: typeof userFacingTrigger === 'object' && userFacingTrigger !== null && !(userFacingTrigger instanceof Date) ? userFacingTrigger == null ? void 0 : userFacingTrigger.channelId : undefined\n    }\n  });\n}\nfunction parseCalendarTrigger(trigger) {\n  if (trigger !== null && typeof trigger === 'object' && 'type' in trigger && trigger.type === SchedulableTriggerInputTypes.CALENDAR) {\n    var repeats = trigger.repeats,\n      calendarTrigger = _objectWithoutProperties(trigger, _excluded);\n    return _objectSpread(_objectSpread({}, calendarTrigger), {}, {\n      repeats: !!repeats,\n      type: 'calendar'\n    });\n  }\n  return undefined;\n}\nfunction parseDateTrigger(trigger) {\n  if (trigger instanceof Date || typeof trigger === 'number') {\n    console.warn(`You are using a deprecated parameter type (${trigger}) for the notification trigger. Use \"{ type: 'date', date: someValue }\" instead.`);\n    return {\n      type: 'date',\n      timestamp: toTimestamp(trigger)\n    };\n  } else if (typeof trigger === 'object' && trigger !== null && 'type' in trigger && trigger.type === SchedulableTriggerInputTypes.DATE && 'date' in trigger) {\n    var result = {\n      type: 'date',\n      timestamp: toTimestamp(trigger.date)\n    };\n    if (trigger.channelId) {\n      result.channelId = trigger.channelId;\n    }\n    return result;\n  } else {\n    return undefined;\n  }\n}\nfunction toTimestamp(date) {\n  if (date instanceof Date) {\n    return date.getTime();\n  }\n  return date;\n}\nfunction parseDailyTrigger(trigger) {\n  if (trigger !== null && typeof trigger === 'object' && 'type' in trigger && trigger.type === SchedulableTriggerInputTypes.DAILY) {\n    var _trigger$hour, _trigger$minute;\n    validateDateComponentsInTrigger(trigger, ['hour', 'minute']);\n    var result = {\n      type: 'daily',\n      hour: (_trigger$hour = trigger.hour) != null ? _trigger$hour : placeholderDateComponentValue,\n      minute: (_trigger$minute = trigger.minute) != null ? _trigger$minute : placeholderDateComponentValue\n    };\n    if (trigger.channelId) {\n      result.channelId = trigger.channelId;\n    }\n    return result;\n  }\n  return undefined;\n}\nfunction parseWeeklyTrigger(trigger) {\n  if (trigger !== null && typeof trigger === 'object' && 'type' in trigger && trigger.type === SchedulableTriggerInputTypes.WEEKLY) {\n    var _trigger$weekday, _trigger$hour2, _trigger$minute2;\n    validateDateComponentsInTrigger(trigger, ['weekday', 'hour', 'minute']);\n    var result = {\n      type: 'weekly',\n      weekday: (_trigger$weekday = trigger.weekday) != null ? _trigger$weekday : placeholderDateComponentValue,\n      hour: (_trigger$hour2 = trigger.hour) != null ? _trigger$hour2 : placeholderDateComponentValue,\n      minute: (_trigger$minute2 = trigger.minute) != null ? _trigger$minute2 : placeholderDateComponentValue\n    };\n    if (trigger.channelId) {\n      result.channelId = trigger.channelId;\n    }\n    return result;\n  }\n  return undefined;\n}\nfunction parseMonthlyTrigger(trigger) {\n  if (trigger !== null && typeof trigger === 'object' && 'type' in trigger && trigger.type === SchedulableTriggerInputTypes.MONTHLY) {\n    var _trigger$day, _trigger$hour3, _trigger$minute3;\n    validateDateComponentsInTrigger(trigger, ['day', 'hour', 'minute']);\n    var result = {\n      type: 'monthly',\n      day: (_trigger$day = trigger.day) != null ? _trigger$day : placeholderDateComponentValue,\n      hour: (_trigger$hour3 = trigger.hour) != null ? _trigger$hour3 : placeholderDateComponentValue,\n      minute: (_trigger$minute3 = trigger.minute) != null ? _trigger$minute3 : placeholderDateComponentValue\n    };\n    if (trigger.channelId) {\n      result.channelId = trigger.channelId;\n    }\n    return result;\n  }\n  return undefined;\n}\nfunction parseYearlyTrigger(trigger) {\n  if (trigger !== null && typeof trigger === 'object' && 'type' in trigger && trigger.type === SchedulableTriggerInputTypes.YEARLY) {\n    var _trigger$month, _trigger$day2, _trigger$hour4, _trigger$minute4;\n    validateDateComponentsInTrigger(trigger, ['month', 'day', 'hour', 'minute']);\n    var result = {\n      type: 'yearly',\n      month: (_trigger$month = trigger.month) != null ? _trigger$month : placeholderDateComponentValue,\n      day: (_trigger$day2 = trigger.day) != null ? _trigger$day2 : placeholderDateComponentValue,\n      hour: (_trigger$hour4 = trigger.hour) != null ? _trigger$hour4 : placeholderDateComponentValue,\n      minute: (_trigger$minute4 = trigger.minute) != null ? _trigger$minute4 : placeholderDateComponentValue\n    };\n    if (trigger.channelId) {\n      result.channelId = trigger.channelId;\n    }\n    return result;\n  }\n  return undefined;\n}\nfunction parseTimeIntervalTrigger(trigger) {\n  if (trigger !== null && typeof trigger === 'object' && 'type' in trigger && trigger.type === SchedulableTriggerInputTypes.TIME_INTERVAL && 'seconds' in trigger && typeof trigger.seconds === 'number') {\n    var _trigger$repeats;\n    var result = {\n      type: 'timeInterval',\n      seconds: trigger.seconds,\n      repeats: (_trigger$repeats = trigger.repeats) != null ? _trigger$repeats : false\n    };\n    if (trigger.channelId) {\n      result.channelId = trigger.channelId;\n    }\n    return result;\n  }\n  return undefined;\n}\nvar placeholderDateComponentValue = -9999;\nfunction validateDateComponentsInTrigger(trigger, components) {\n  var anyTriggerType = trigger;\n  components.forEach(function (component) {\n    if (!(component in anyTriggerType)) {\n      throw new TypeError(`The ${component} parameter needs to be present`);\n    }\n    if (typeof anyTriggerType[component] !== 'number') {\n      throw new TypeError(`The ${component} parameter should be a number`);\n    }\n    switch (component) {\n      case 'month':\n        {\n          var month = anyTriggerType.month;\n          if (month < 0 || month > 11) {\n            throw new RangeError(`The month parameter needs to be between 0 and 11. Found: ${month}`);\n          }\n          break;\n        }\n      case 'day':\n        {\n          var day = anyTriggerType.day;\n          var _month = anyTriggerType.month !== undefined ? anyTriggerType.month : new Date().getMonth();\n          var daysInGivenMonth = daysInMonth(_month);\n          if (day < 1 || day > daysInGivenMonth) {\n            throw new RangeError(`The day parameter for month ${_month} must be between 1 and ${daysInGivenMonth}. Found: ${day}`);\n          }\n          break;\n        }\n      case 'weekday':\n        {\n          var weekday = anyTriggerType.weekday;\n          if (weekday < 1 || weekday > 7) {\n            throw new RangeError(`The weekday parameter needs to be between 1 and 7. Found: ${weekday}`);\n          }\n          break;\n        }\n      case 'hour':\n        {\n          var hour = anyTriggerType.hour;\n          if (hour < 0 || hour > 23) {\n            throw new RangeError(`The hour parameter needs to be between 0 and 23. Found: ${hour}`);\n          }\n          break;\n        }\n      case 'minute':\n        {\n          var minute = anyTriggerType.minute;\n          if (minute < 0 || minute > 59) {\n            throw new RangeError(`The minute parameter needs to be between 0 and 59. Found: ${minute}`);\n          }\n          break;\n        }\n    }\n  });\n}\nfunction daysInMonth() {\n  var month = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n  var year = arguments.length > 1 ? arguments[1] : undefined;\n  return new Date(year != null ? year : 2000, month + 1, 0).getDate();\n}","map":{"version":3,"names":["Platform","UnavailabilityError","uuid","NotificationScheduler","SchedulableTriggerInputTypes","hasValidTriggerObject","scheduleNotificationAsync","_x","_scheduleNotificationAsync","apply","arguments","_asyncToGenerator","request","_request$identifier","identifier","v4","content","parseTrigger","trigger","userFacingTrigger","undefined","TypeError","dateTrigger","parseDateTrigger","calendarTrigger","parseCalendarTrigger","dailyTrigger","parseDailyTrigger","weeklyTrigger","parseWeeklyTrigger","monthlyTrigger","parseMonthlyTrigger","yearlyTrigger","parseYearlyTrigger","timeIntervalTrigger","parseTimeIntervalTrigger","select","default","android","type","channelId","Date","CALENDAR","repeats","_objectWithoutProperties","_excluded","_objectSpread","console","warn","timestamp","toTimestamp","DATE","result","date","getTime","DAILY","_trigger$hour","_trigger$minute","validateDateComponentsInTrigger","hour","placeholderDateComponentValue","minute","WEEKLY","_trigger$weekday","_trigger$hour2","_trigger$minute2","weekday","MONTHLY","_trigger$day","_trigger$hour3","_trigger$minute3","day","YEARLY","_trigger$month","_trigger$day2","_trigger$hour4","_trigger$minute4","month","TIME_INTERVAL","seconds","_trigger$repeats","components","anyTriggerType","forEach","component","RangeError","getMonth","daysInGivenMonth","daysInMonth","length","year","getDate"],"sources":["C:\\GrowPathAI-UI\\node_modules\\expo-notifications\\src\\scheduleNotificationAsync.ts"],"sourcesContent":["import { Platform, UnavailabilityError, uuid } from 'expo-modules-core';\n\nimport NotificationScheduler from './NotificationScheduler';\nimport {\n  NativeCalendarTriggerInput,\n  NativeDailyTriggerInput,\n  NativeDateTriggerInput,\n  NativeMonthlyTriggerInput,\n  NativeNotificationTriggerInput,\n  NativeTimeIntervalTriggerInput,\n  NativeWeeklyTriggerInput,\n  NativeYearlyTriggerInput,\n} from './NotificationScheduler.types';\nimport {\n  NotificationRequestInput,\n  NotificationTriggerInput,\n  SchedulableTriggerInputTypes,\n} from './Notifications.types';\nimport { hasValidTriggerObject } from './hasValidTriggerObject';\n\n/**\n * Schedules a notification to be triggered in the future.\n * > **Note:** This does not mean that the notification will be presented when it is triggered.\n * For the notification to be presented you have to set a notification handler with [`setNotificationHandler`](#setnotificationhandlerhandler)\n * that will return an appropriate notification behavior. For more information see the example below.\n * @param request An object describing the notification to be triggered.\n * @return Returns a Promise resolving to a string which is a notification identifier you can later use to cancel the notification or to identify an incoming notification.\n * @example\n * # Schedule the notification that will trigger once, in one minute from now\n * ```ts\n * import * as Notifications from 'expo-notifications';\n *\n * Notifications.scheduleNotificationAsync({\n *   content: {\n *     title: \"Time's up!\",\n *     body: 'Change sides!',\n *   },\n *   trigger: {\n *     type: Notifications.SchedulableTriggerInputTypes.TIME_INTERVAL,\n *     seconds: 60,\n *   },\n * });\n * ```\n *\n * # Schedule the notification that will trigger repeatedly, every 20 minutes\n * ```ts\n * import * as Notifications from 'expo-notifications';\n *\n * Notifications.scheduleNotificationAsync({\n *   content: {\n *     title: 'Remember to drink water!',\n *   },\n *   trigger: {\n *     type: Notifications.SchedulableTriggerInputTypes.TIME_INTERVAL,\n *     seconds: 60 * 20,\n *     repeats: true,\n *   },\n * });\n * ```\n *\n * # Schedule the notification that will trigger once, at the beginning of next hour\n * ```ts\n * import * as Notifications from 'expo-notifications';\n *\n * const date = new Date(Date.now() + 60 * 60 * 1000);\n * date.setMinutes(0);\n * date.setSeconds(0);\n *\n * Notifications.scheduleNotificationAsync({\n *   content: {\n *     title: 'Happy new hour!',\n *   },\n *   trigger: {\n *     type: Notifications.SchedulableTriggerInputTypes.DATE,\n *     date\n *   },\n * });\n * ```\n * @header schedule\n */\nexport default async function scheduleNotificationAsync(\n  request: NotificationRequestInput\n): Promise<string> {\n  if (!NotificationScheduler.scheduleNotificationAsync) {\n    throw new UnavailabilityError('Notifications', 'scheduleNotificationAsync');\n  }\n\n  return await NotificationScheduler.scheduleNotificationAsync(\n    request.identifier ?? uuid.v4(),\n    request.content,\n    parseTrigger(request.trigger)\n  );\n}\n\ntype ValidTriggerDateComponents = 'month' | 'day' | 'weekday' | 'hour' | 'minute';\n\nexport function parseTrigger(\n  userFacingTrigger: NotificationTriggerInput\n): NativeNotificationTriggerInput {\n  if (userFacingTrigger === null) {\n    return null;\n  }\n\n  if (userFacingTrigger === undefined) {\n    throw new TypeError(\n      'Encountered an `undefined` notification trigger. If you want to trigger the notification immediately, pass in an explicit `null` value.'\n    );\n  }\n\n  if (!hasValidTriggerObject(userFacingTrigger)) {\n    throw new TypeError(\n      `The \\`trigger\\` object you provided is invalid. It needs to contain a \\`type\\` or \\`channelId\\` entry. Refer to the documentation to update your code: https://docs.expo.dev/versions/latest/sdk/notifications/#notificationtriggerinput`\n    );\n  }\n  const dateTrigger = parseDateTrigger(userFacingTrigger);\n  if (dateTrigger) {\n    return dateTrigger;\n  }\n  const calendarTrigger = parseCalendarTrigger(userFacingTrigger);\n  if (calendarTrigger) {\n    return calendarTrigger;\n  }\n  const dailyTrigger = parseDailyTrigger(userFacingTrigger);\n  if (dailyTrigger) {\n    return dailyTrigger;\n  }\n  const weeklyTrigger = parseWeeklyTrigger(userFacingTrigger);\n  if (weeklyTrigger) {\n    return weeklyTrigger;\n  }\n  const monthlyTrigger = parseMonthlyTrigger(userFacingTrigger);\n  if (monthlyTrigger) {\n    return monthlyTrigger;\n  }\n  const yearlyTrigger = parseYearlyTrigger(userFacingTrigger);\n  if (yearlyTrigger) {\n    return yearlyTrigger;\n  }\n  const timeIntervalTrigger = parseTimeIntervalTrigger(userFacingTrigger);\n  if (timeIntervalTrigger) {\n    return timeIntervalTrigger;\n  }\n  return Platform.select({\n    default: null, // There's no notion of channels on platforms other than Android.\n    android: {\n      type: 'channel',\n      channelId:\n        typeof userFacingTrigger === 'object' &&\n        userFacingTrigger !== null &&\n        !(userFacingTrigger instanceof Date)\n          ? userFacingTrigger?.channelId\n          : undefined,\n    },\n  });\n}\n\nfunction parseCalendarTrigger(\n  trigger: NotificationTriggerInput\n): NativeCalendarTriggerInput | undefined {\n  if (\n    trigger !== null &&\n    typeof trigger === 'object' &&\n    'type' in trigger &&\n    trigger.type === SchedulableTriggerInputTypes.CALENDAR\n  ) {\n    const { repeats, ...calendarTrigger } = trigger;\n    return { ...calendarTrigger, repeats: !!repeats, type: 'calendar' };\n  }\n  return undefined;\n}\n\nfunction parseDateTrigger(trigger: NotificationTriggerInput): NativeDateTriggerInput | undefined {\n  if (trigger instanceof Date || typeof trigger === 'number') {\n    // TODO @vonovak this branch is not be used by people using TS\n    // but was part of the public api previously so we keep it for a bit for JS users\n    console.warn(\n      `You are using a deprecated parameter type (${trigger}) for the notification trigger. Use \"{ type: 'date', date: someValue }\" instead.`\n    );\n    return { type: 'date', timestamp: toTimestamp(trigger) };\n  } else if (\n    typeof trigger === 'object' &&\n    trigger !== null &&\n    'type' in trigger &&\n    trigger.type === SchedulableTriggerInputTypes.DATE &&\n    'date' in trigger\n  ) {\n    const result: NativeDateTriggerInput = {\n      type: 'date',\n      timestamp: toTimestamp(trigger.date),\n    };\n    if (trigger.channelId) {\n      result.channelId = trigger.channelId;\n    }\n    return result;\n  } else {\n    return undefined;\n  }\n}\n\nfunction toTimestamp(date: number | Date) {\n  if (date instanceof Date) {\n    return date.getTime();\n  }\n  return date;\n}\n\nfunction parseDailyTrigger(trigger: NotificationTriggerInput): NativeDailyTriggerInput | undefined {\n  if (\n    trigger !== null &&\n    typeof trigger === 'object' &&\n    'type' in trigger &&\n    trigger.type === SchedulableTriggerInputTypes.DAILY\n  ) {\n    validateDateComponentsInTrigger(trigger, ['hour', 'minute']);\n    const result: NativeDailyTriggerInput = {\n      type: 'daily',\n      hour: trigger.hour ?? placeholderDateComponentValue,\n      minute: trigger.minute ?? placeholderDateComponentValue,\n    };\n    if (trigger.channelId) {\n      result.channelId = trigger.channelId;\n    }\n    return result;\n  }\n  return undefined;\n}\n\nfunction parseWeeklyTrigger(\n  trigger: NotificationTriggerInput\n): NativeWeeklyTriggerInput | undefined {\n  if (\n    trigger !== null &&\n    typeof trigger === 'object' &&\n    'type' in trigger &&\n    trigger.type === SchedulableTriggerInputTypes.WEEKLY\n  ) {\n    validateDateComponentsInTrigger(trigger, ['weekday', 'hour', 'minute']);\n    const result: NativeWeeklyTriggerInput = {\n      type: 'weekly',\n      weekday: trigger.weekday ?? placeholderDateComponentValue,\n      hour: trigger.hour ?? placeholderDateComponentValue,\n      minute: trigger.minute ?? placeholderDateComponentValue,\n    };\n    if (trigger.channelId) {\n      result.channelId = trigger.channelId;\n    }\n    return result;\n  }\n  return undefined;\n}\n\nfunction parseMonthlyTrigger(\n  trigger: NotificationTriggerInput\n): NativeMonthlyTriggerInput | undefined {\n  if (\n    trigger !== null &&\n    typeof trigger === 'object' &&\n    'type' in trigger &&\n    trigger.type === SchedulableTriggerInputTypes.MONTHLY\n  ) {\n    validateDateComponentsInTrigger(trigger, ['day', 'hour', 'minute']);\n    const result: NativeMonthlyTriggerInput = {\n      type: 'monthly',\n      day: trigger.day ?? placeholderDateComponentValue,\n      hour: trigger.hour ?? placeholderDateComponentValue,\n      minute: trigger.minute ?? placeholderDateComponentValue,\n    };\n    if (trigger.channelId) {\n      result.channelId = trigger.channelId;\n    }\n    return result;\n  }\n  return undefined;\n}\n\nfunction parseYearlyTrigger(\n  trigger: NotificationTriggerInput\n): NativeYearlyTriggerInput | undefined {\n  if (\n    trigger !== null &&\n    typeof trigger === 'object' &&\n    'type' in trigger &&\n    trigger.type === SchedulableTriggerInputTypes.YEARLY\n  ) {\n    validateDateComponentsInTrigger(trigger, ['month', 'day', 'hour', 'minute']);\n    const result: NativeYearlyTriggerInput = {\n      type: 'yearly',\n      month: trigger.month ?? placeholderDateComponentValue,\n      day: trigger.day ?? placeholderDateComponentValue,\n      hour: trigger.hour ?? placeholderDateComponentValue,\n      minute: trigger.minute ?? placeholderDateComponentValue,\n    };\n    if (trigger.channelId) {\n      result.channelId = trigger.channelId;\n    }\n    return result;\n  }\n  return undefined;\n}\n\nfunction parseTimeIntervalTrigger(\n  trigger: NotificationTriggerInput\n): NativeTimeIntervalTriggerInput | undefined {\n  if (\n    trigger !== null &&\n    typeof trigger === 'object' &&\n    'type' in trigger &&\n    trigger.type === SchedulableTriggerInputTypes.TIME_INTERVAL &&\n    'seconds' in trigger &&\n    typeof trigger.seconds === 'number'\n  ) {\n    const result: NativeTimeIntervalTriggerInput = {\n      type: 'timeInterval',\n      seconds: trigger.seconds,\n      repeats: trigger.repeats ?? false,\n    };\n    if (trigger.channelId) {\n      result.channelId = trigger.channelId;\n    }\n    return result;\n  }\n  return undefined;\n}\n\n// Needed only to satisfy Typescript types for validated date components\nconst placeholderDateComponentValue = -9999;\n\nfunction validateDateComponentsInTrigger(\n  trigger: NonNullable<NotificationTriggerInput>,\n  components: readonly ValidTriggerDateComponents[]\n) {\n  const anyTriggerType = trigger as any;\n  components.forEach((component) => {\n    if (!(component in anyTriggerType)) {\n      throw new TypeError(`The ${component} parameter needs to be present`);\n    }\n    if (typeof anyTriggerType[component] !== 'number') {\n      throw new TypeError(`The ${component} parameter should be a number`);\n    }\n    switch (component) {\n      case 'month': {\n        const { month } = anyTriggerType;\n        if (month < 0 || month > 11) {\n          throw new RangeError(`The month parameter needs to be between 0 and 11. Found: ${month}`);\n        }\n        break;\n      }\n      case 'day': {\n        const day = anyTriggerType.day;\n        const month =\n          anyTriggerType.month !== undefined ? anyTriggerType.month : new Date().getMonth();\n        const daysInGivenMonth = daysInMonth(month);\n        if (day < 1 || day > daysInGivenMonth) {\n          throw new RangeError(\n            `The day parameter for month ${month} must be between 1 and ${daysInGivenMonth}. Found: ${day}`\n          );\n        }\n        break;\n      }\n      case 'weekday': {\n        const { weekday } = anyTriggerType;\n        if (weekday < 1 || weekday > 7) {\n          throw new RangeError(\n            `The weekday parameter needs to be between 1 and 7. Found: ${weekday}`\n          );\n        }\n        break;\n      }\n      case 'hour': {\n        const { hour } = anyTriggerType;\n        if (hour < 0 || hour > 23) {\n          throw new RangeError(`The hour parameter needs to be between 0 and 23. Found: ${hour}`);\n        }\n        break;\n      }\n      case 'minute': {\n        const { minute } = anyTriggerType;\n        if (minute < 0 || minute > 59) {\n          throw new RangeError(\n            `The minute parameter needs to be between 0 and 59. Found: ${minute}`\n          );\n        }\n        break;\n      }\n    }\n  });\n}\n\n/**\n * Determines the number of days in the given month (or January if omitted).\n * If year is specified, it will include leap year logic, else it will always assume a leap year\n */\nfunction daysInMonth(month: number = 0, year?: number) {\n  return new Date(year ?? 2000, month + 1, 0).getDate();\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}