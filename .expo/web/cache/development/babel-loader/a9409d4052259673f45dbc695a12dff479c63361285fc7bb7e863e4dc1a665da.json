{"ast":null,"code":"import _asyncToGenerator from \"@babel/runtime/helpers/asyncToGenerator\";\nimport { LegacyEventEmitter, UnavailabilityError } from 'expo-modules-core';\nimport NotificationsEmitterModule from \"./NotificationsEmitterModule\";\nimport { mapNotification, mapNotificationResponse } from \"./utils/mapNotificationResponse\";\nvar emitter = new LegacyEventEmitter(NotificationsEmitterModule);\nvar didReceiveNotificationEventName = 'onDidReceiveNotification';\nvar didDropNotificationsEventName = 'onNotificationsDeleted';\nvar didReceiveNotificationResponseEventName = 'onDidReceiveNotificationResponse';\nvar didClearNotificationResponseEventName = 'onDidClearNotificationResponse';\nexport var DEFAULT_ACTION_IDENTIFIER = 'expo.modules.notifications.actions.DEFAULT';\nexport function addNotificationReceivedListener(listener) {\n  return emitter.addListener(didReceiveNotificationEventName, function (notification) {\n    var mappedNotification = mapNotification(notification);\n    listener(mappedNotification);\n  });\n}\nexport function addNotificationsDroppedListener(listener) {\n  return emitter.addListener(didDropNotificationsEventName, listener);\n}\nexport function addNotificationResponseReceivedListener(listener) {\n  return emitter.addListener(didReceiveNotificationResponseEventName, function (response) {\n    var mappedResponse = mapNotificationResponse(response);\n    listener(mappedResponse);\n  });\n}\nexport function getLastNotificationResponseAsync() {\n  return _getLastNotificationResponseAsync.apply(this, arguments);\n}\nfunction _getLastNotificationResponseAsync() {\n  _getLastNotificationResponseAsync = _asyncToGenerator(function* () {\n    return getLastNotificationResponse();\n  });\n  return _getLastNotificationResponseAsync.apply(this, arguments);\n}\nexport function getLastNotificationResponse() {\n  if (!NotificationsEmitterModule.getLastNotificationResponse) {\n    throw new UnavailabilityError('ExpoNotifications', 'getLastNotificationResponse');\n  }\n  var response = NotificationsEmitterModule.getLastNotificationResponse();\n  var mappedResponse = response ? mapNotificationResponse(response) : response;\n  return mappedResponse;\n}\nexport function clearLastNotificationResponseAsync() {\n  return _clearLastNotificationResponseAsync.apply(this, arguments);\n}\nfunction _clearLastNotificationResponseAsync() {\n  _clearLastNotificationResponseAsync = _asyncToGenerator(function* () {\n    clearLastNotificationResponse();\n  });\n  return _clearLastNotificationResponseAsync.apply(this, arguments);\n}\nexport function clearLastNotificationResponse() {\n  if (!NotificationsEmitterModule.clearLastNotificationResponse) {\n    throw new UnavailabilityError('ExpoNotifications', 'clearLastNotificationResponse');\n  }\n  NotificationsEmitterModule.clearLastNotificationResponse();\n  emitter.emit(didClearNotificationResponseEventName, []);\n}\nexport function addNotificationResponseClearedListener(listener) {\n  return emitter.addListener(didClearNotificationResponseEventName, listener);\n}","map":{"version":3,"names":["LegacyEventEmitter","UnavailabilityError","NotificationsEmitterModule","mapNotification","mapNotificationResponse","emitter","didReceiveNotificationEventName","didDropNotificationsEventName","didReceiveNotificationResponseEventName","didClearNotificationResponseEventName","DEFAULT_ACTION_IDENTIFIER","addNotificationReceivedListener","listener","addListener","notification","mappedNotification","addNotificationsDroppedListener","addNotificationResponseReceivedListener","response","mappedResponse","getLastNotificationResponseAsync","_getLastNotificationResponseAsync","apply","arguments","_asyncToGenerator","getLastNotificationResponse","clearLastNotificationResponseAsync","_clearLastNotificationResponseAsync","clearLastNotificationResponse","emit","addNotificationResponseClearedListener"],"sources":["C:\\GrowPathAI-UI\\node_modules\\expo-notifications\\src\\NotificationsEmitter.ts"],"sourcesContent":["import { LegacyEventEmitter, type EventSubscription, UnavailabilityError } from 'expo-modules-core';\n\nimport { Notification, NotificationResponse } from './Notifications.types';\nimport NotificationsEmitterModule from './NotificationsEmitterModule';\nimport { mapNotification, mapNotificationResponse } from './utils/mapNotificationResponse';\n\n// Web uses SyntheticEventEmitter\nconst emitter = new LegacyEventEmitter(NotificationsEmitterModule);\n\nconst didReceiveNotificationEventName = 'onDidReceiveNotification';\nconst didDropNotificationsEventName = 'onNotificationsDeleted';\nconst didReceiveNotificationResponseEventName = 'onDidReceiveNotificationResponse';\nconst didClearNotificationResponseEventName = 'onDidClearNotificationResponse';\n\n// @docsMissing\nexport const DEFAULT_ACTION_IDENTIFIER = 'expo.modules.notifications.actions.DEFAULT';\n\n/**\n * Listeners registered by this method will be called whenever a notification is received while the app is running.\n * @param listener A function accepting a notification ([`Notification`](#notification)) as an argument.\n * @return An [`EventSubscription`](#eventsubscription) object represents the subscription of the provided listener.\n * @example Registering a notification listener using a React hook:\n * ```jsx\n * import React from 'react';\n * import * as Notifications from 'expo-notifications';\n *\n * export default function App() {\n *   React.useEffect(() => {\n *     const subscription = Notifications.addNotificationReceivedListener(notification => {\n *       console.log(notification);\n *     });\n *     return () => subscription.remove();\n *   }, []);\n *\n *   return (\n *     // Your app content\n *   );\n * }\n * ```\n * @header listen\n */\nexport function addNotificationReceivedListener(\n  listener: (event: Notification) => void\n): EventSubscription {\n  return emitter.addListener<Notification>(\n    didReceiveNotificationEventName,\n    (notification: Notification) => {\n      const mappedNotification = mapNotification(notification);\n      listener(mappedNotification);\n    }\n  );\n}\n\n/**\n * Listeners registered by this method will be called whenever some notifications have been dropped by the server.\n * Applicable only to Firebase Cloud Messaging which we use as a notifications service on Android. It corresponds to `onDeletedMessages()` callback.\n * More information can be found in [Firebase docs](https://firebase.google.com/docs/cloud-messaging/android/receive#override-ondeletedmessages).\n * @param listener A callback function.\n * @return An [`EventSubscription`](#eventsubscription) object represents the subscription of the provided listener.\n * @header listen\n */\nexport function addNotificationsDroppedListener(listener: () => void): EventSubscription {\n  return emitter.addListener<void>(didDropNotificationsEventName, listener);\n}\n\n/**\n * Listeners registered by this method will be called whenever a user interacts with a notification (for example, taps on it).\n * @param listener A function accepting notification response ([`NotificationResponse`](#notificationresponse)) as an argument.\n * @return An [`EventSubscription`](#eventsubscription) object represents the subscription of the provided listener.\n * @example Register a notification responder listener:\n * ```jsx\n * import React from 'react';\n * import { Linking } from 'react-native';\n * import * as Notifications from 'expo-notifications';\n *\n * export default function Container() {\n *   React.useEffect(() => {\n *     const subscription = Notifications.addNotificationResponseReceivedListener(response => {\n *       const url = response.notification.request.content.data.url;\n *       Linking.openURL(url);\n *     });\n *     return () => subscription.remove();\n *   }, []);\n *\n *   return (\n *     // Your app content\n *   );\n * }\n * ```\n * @header listen\n */\nexport function addNotificationResponseReceivedListener(\n  listener: (event: NotificationResponse) => void\n): EventSubscription {\n  return emitter.addListener<NotificationResponse>(\n    didReceiveNotificationResponseEventName,\n    (response: NotificationResponse) => {\n      const mappedResponse = mapNotificationResponse(response);\n      listener(mappedResponse);\n    }\n  );\n}\n\n/**\n *\n * Gets the notification response received most recently\n * (a notification response designates an interaction with a notification, such as tapping on it).\n *\n * - `null` - if no notification response has been received yet\n * - a [`NotificationResponse`](#notificationresponse) object - if a notification response was received\n *\n * @deprecated Use `getLastNotificationResponse` instead.\n */\nexport async function getLastNotificationResponseAsync(): Promise<NotificationResponse | null> {\n  return getLastNotificationResponse();\n}\n\n/**\n * Gets the notification response that was received most recently\n * (a notification response designates an interaction with a notification, such as tapping on it).\n *\n * - `null` - if no notification response has been received yet\n * - a [`NotificationResponse`](#notificationresponse) object - if a notification response was received\n */\nexport function getLastNotificationResponse(): NotificationResponse | null {\n  if (!NotificationsEmitterModule.getLastNotificationResponse) {\n    throw new UnavailabilityError('ExpoNotifications', 'getLastNotificationResponse');\n  }\n  const response = NotificationsEmitterModule.getLastNotificationResponse();\n  const mappedResponse = response ? mapNotificationResponse(response) : response;\n  return mappedResponse;\n}\n\n/**\n * Clears the notification response that was received most recently. May be used\n * when an app selects a route based on the notification response, and it is undesirable\n * to continue selecting the route after the response has already been handled.\n *\n * If a component is using the [`useLastNotificationResponse`](#uselastnotificationresponse) hook,\n * this call will also clear the value returned by the hook.\n *\n * @deprecated Use `clearLastNotificationResponse` instead.\n * @return A promise that resolves if the native call was successful.\n */\nexport async function clearLastNotificationResponseAsync(): Promise<void> {\n  clearLastNotificationResponse();\n}\n\n/**\n * Clears the notification response that was received most recently. May be used\n * when an app selects a route based on the notification response, and it is undesirable\n * to continue selecting the route after the response has already been handled.\n *\n * If a component is using the [`useLastNotificationResponse`](#uselastnotificationresponse) hook,\n * this call will also clear the value returned by the hook.\n *\n */\nexport function clearLastNotificationResponse(): void {\n  if (!NotificationsEmitterModule.clearLastNotificationResponse) {\n    throw new UnavailabilityError('ExpoNotifications', 'clearLastNotificationResponse');\n  }\n  NotificationsEmitterModule.clearLastNotificationResponse();\n  // Emit event to clear any useLastNotificationResponse hooks, after native call succeeds\n  emitter.emit(didClearNotificationResponseEventName, []);\n}\n\n/**\n * @hidden\n */\nexport function addNotificationResponseClearedListener(listener: () => void): EventSubscription {\n  return emitter.addListener<void>(didClearNotificationResponseEventName, listener);\n}\n"],"mappings":";AAAA,SAASA,kBAAkB,EAA0BC,mBAAmB,QAAQ,mBAAmB;AAGnG,OAAOC,0BAA0B;AACjC,SAASC,eAAe,EAAEC,uBAAuB;AAGjD,IAAMC,OAAO,GAAG,IAAIL,kBAAkB,CAACE,0BAA0B,CAAC;AAElE,IAAMI,+BAA+B,GAAG,0BAA0B;AAClE,IAAMC,6BAA6B,GAAG,wBAAwB;AAC9D,IAAMC,uCAAuC,GAAG,kCAAkC;AAClF,IAAMC,qCAAqC,GAAG,gCAAgC;AAG9E,OAAO,IAAMC,yBAAyB,GAAG,4CAA4C;AA0BrF,OAAM,SAAUC,+BAA+BA,CAC7CC,QAAuC;EAEvC,OAAOP,OAAO,CAACQ,WAAW,CACxBP,+BAA+B,EAC/B,UAACQ,YAA0B,EAAI;IAC7B,IAAMC,kBAAkB,GAAGZ,eAAe,CAACW,YAAY,CAAC;IACxDF,QAAQ,CAACG,kBAAkB,CAAC;EAC9B,CAAC,CACF;AACH;AAUA,OAAM,SAAUC,+BAA+BA,CAACJ,QAAoB;EAClE,OAAOP,OAAO,CAACQ,WAAW,CAAON,6BAA6B,EAAEK,QAAQ,CAAC;AAC3E;AA4BA,OAAM,SAAUK,uCAAuCA,CACrDL,QAA+C;EAE/C,OAAOP,OAAO,CAACQ,WAAW,CACxBL,uCAAuC,EACvC,UAACU,QAA8B,EAAI;IACjC,IAAMC,cAAc,GAAGf,uBAAuB,CAACc,QAAQ,CAAC;IACxDN,QAAQ,CAACO,cAAc,CAAC;EAC1B,CAAC,CACF;AACH;AAYA,gBAAsBC,gCAAgCA,CAAA;EAAA,OAAAC,iCAAA,CAAAC,KAAA,OAAAC,SAAA;AAAA;AAErD,SAAAF,kCAAA;EAAAA,iCAAA,GAAAG,iBAAA,CAFM,aAA+C;IACpD,OAAOC,2BAA2B,EAAE;EACtC,CAAC;EAAA,OAAAJ,iCAAA,CAAAC,KAAA,OAAAC,SAAA;AAAA;AASD,OAAM,SAAUE,2BAA2BA,CAAA;EACzC,IAAI,CAACvB,0BAA0B,CAACuB,2BAA2B,EAAE;IAC3D,MAAM,IAAIxB,mBAAmB,CAAC,mBAAmB,EAAE,6BAA6B,CAAC;EACnF;EACA,IAAMiB,QAAQ,GAAGhB,0BAA0B,CAACuB,2BAA2B,EAAE;EACzE,IAAMN,cAAc,GAAGD,QAAQ,GAAGd,uBAAuB,CAACc,QAAQ,CAAC,GAAGA,QAAQ;EAC9E,OAAOC,cAAc;AACvB;AAaA,gBAAsBO,kCAAkCA,CAAA;EAAA,OAAAC,mCAAA,CAAAL,KAAA,OAAAC,SAAA;AAAA;AAEvD,SAAAI,oCAAA;EAAAA,mCAAA,GAAAH,iBAAA,CAFM,aAAiD;IACtDI,6BAA6B,EAAE;EACjC,CAAC;EAAA,OAAAD,mCAAA,CAAAL,KAAA,OAAAC,SAAA;AAAA;AAWD,OAAM,SAAUK,6BAA6BA,CAAA;EAC3C,IAAI,CAAC1B,0BAA0B,CAAC0B,6BAA6B,EAAE;IAC7D,MAAM,IAAI3B,mBAAmB,CAAC,mBAAmB,EAAE,+BAA+B,CAAC;EACrF;EACAC,0BAA0B,CAAC0B,6BAA6B,EAAE;EAE1DvB,OAAO,CAACwB,IAAI,CAACpB,qCAAqC,EAAE,EAAE,CAAC;AACzD;AAKA,OAAM,SAAUqB,sCAAsCA,CAAClB,QAAoB;EACzE,OAAOP,OAAO,CAACQ,WAAW,CAAOJ,qCAAqC,EAAEG,QAAQ,CAAC;AACnF","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}